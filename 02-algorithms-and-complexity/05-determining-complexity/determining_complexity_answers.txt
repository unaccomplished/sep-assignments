1. What's the Big-O of the following algorithm? Submit your work and reasoning
with your solution.

goodbye_world.rb
  def goodbye_world(n)
   puts "Goodbye World! #{n}"
  end

  ANSWER: O(1) or constant time. This will always take the same amount of time
  to execute, so it is constant.

2. What's the Big-O of the following algorithm? Submit your work and reasoning
with your solution.

find_largest.rb
  def find_largest(collection)
   largest = collection[0]
   collection.length.times do |i|
     if collection[i] >= largest
       largest = collection[i]
     end
   end
   largest
  end

  ANSWER: O(n) or linear time. As the collection array grows larger, the number
  of operations will grow at the same rate, so this is linear.

3. What's the Big-O of the following algorithm? Submit your work and reasoning
with your solution.

find_largest_2D_array.rb
  def find_largest(collection)
   largest = collection[0][0]
   collection.length.times do |i|
     subcollection = collection[i]
     subcollection.length.times do |j|
       if subcollection[j] >= largest
         largest = subcollection[j]
       end
     end
   end
   largest
  end

  ANSWER: O(n^2) or quadratic time. This has two loops that the 2D array will
  iterate through, so it will have a Big-O of n*n or Big-O of n^2.

4. What's the Big-O of the following algorithm? Submit your work and reasoning
with your solution.

numbers_recursive.rb
  def numbers(n)
   if (n == 0)
     return 0
   elsif (n == 1)
     return 1
   else
     return numbers(n-1) + numbers(n-2)
   end
  end

  ANSWER: O(n log n) or loglinear time. There are two recursive calls, so this
  is Big-O of 2 log n, or n log n.

5. What's the Big-O of the following algorithm? Submit your work and reasoning
with your solution.

numbers_iterative.rb
  def iterative(n)
   num1 = 0
   num2 = 1

   i = 0
   while i < n-1
     tmp = num1 + num2
     num1 = num2
     num2 = tmp
     i+=1
   end

   num2
  end

  ANSWER: There is one while loop, so Big-O is O(n) or linear time.

6. What's the Big-O of the following algorithm? Submit your work and reasoning
with your solution.

sort.rb
  def sort(collection, from=0, to=nil)
   if to == nil
     # Sort the whole collection, by default
     to = collection.count - 1
   end

   if from >= to
     # Done sorting
     return
   end

   # Take a pivot value, at the far left
   pivot = collection[from]

   # Min and Max pointers
   min = from
   max = to

   # Current free slot
   free = min

   while min < max
     if free == min # Evaluate collection[max]
       if collection[max] <= pivot # Smaller than pivot, must move
         collection[free] = collection[max]
         min += 1
         free = max
       else
         max -= 1
       end
     elsif free == max # Evaluate collection[min]
       if collection[min] >= pivot # Bigger than pivot, must move
         collection[free] = collection[min]
         max -= 1
         free = min
       else
         min += 1
       end
     else
       raise "Inconsistent state"
     end
   end

   collection[free] = pivot

   sort collection, from, free - 1
   sort collection, free + 1, to

   collection
  end

  ANSWER: There are two recursive calls which is 2 log n , and one while loop,
  adding an additional n, making Big-O of 2 log (n + n) or O(nlog(2n)).
